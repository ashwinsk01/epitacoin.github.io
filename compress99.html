<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="FUC">
      <meta name="author" content="ashthehacker">
      <title>Compression</title>
      <!-- Css -->
      <link href="css/bootstrap.css" rel="stylesheet">
      <link href="css/style.css" rel="stylesheet">
      <link href="https://dl.dropbox.com/s/w9ywuzlvqvv7kln/codepen-template.scss" rel="stylesheet" />

   </head>
   <body>
      <nav class="navbar navbar-default color-fill navbar-fixed-top">
         <div class="col-md-12">
            <div class="nav">
               <button class="btn-nav">
               <span class="icon-bar top"></span>
               <span class="icon-bar middle"></span>
               <span class="icon-bar bottom"></span>
               </button>
            </div>
            <div class="nav-content hideNav hidden">
               <ul class="nav-list vcenter">
                  <li class="nav-item"><a class="item-anchor" href="index.html">Home</a></li>
                  <li class="nav-item"><a class="item-anchor" href="articles.html">Articles </a></li>
                  <li class="nav-item"><a class="item-anchor" href="download.html">Upload</a></li>
               </ul>
            </div>
         </div>
      </nav>
       
       <header class="zoom">
	     <img src="img/artimg/compress.jpg">
         <center><h1 class = "temph1">Comp</h1></center>
       </header>
       <main role="main">
	    <div class="content max-scroll-y">
		  <h1>Compression Algorithms</h1>
		   <a href="links.html" alt="" target="_blank">Sources</a>
            <p style="font-family:Georgia,sans-serif"><b>Huffman Vs LZ77 & LZ78</b>: in LZ77 & LZ78 algorithm , the algorithm works in such way that it look for a sequences of elements (For this example we will use a word in a text file ) in the desired file and will replace each of occurrences of that element by a reference (pointer) that takes the form of ( J , E ) in a binary form (only 2 bytes), where: <br><br>

J is the amount of leaps that we have to take backways to achieve that element. E is the length of the elements.<br>

As an example, let’s consider the following text: A computer handles all the computational power.<br>

We can replace the word (Comput) by (00011000,00000110) which refers to the previous existence of the word which saves us a lot of space.<br><br>

In our case , we found some problems in this algorithm. This algorithm is purely based on the reoccurrence of some patterns and the amount of leaps ,which is not very efficient when you’re working with such a large database, in another way , what’s the probability of seeing (4112512414) one more time?? which is very very small, and that’s why we’re voted against it.<br><br>

Huffman vs RLE : As we seen in our practical , RLE algorithm is an algorithm which’s sole purpose is to compress data that has the same occurrences Sequentially buy writing it In the form of (x o ) where:<br><br>

X is the number of occurrences sequentially<br><br>

O is that element that keep occurring.<br>

This is not very efficient in our network because most of the data will not be identically sequential</p>
    <footer> 
       <h5 align = "center"><i class="fa fa-copyright fa-flip-horizontal"></i> EPICOIN</h5>
    </footer>
		
	</div>
	
</main>
      <!-- script -->
      <script src="js/jquery.js"></script>
      <script src="js/bootstrap.min.js"></script>
      <script src="js/lightbox-plus-jquery.js"></script>
      <script src="js/jquery.shuffle.min.js"></script>
      <script src="js/modernizr.js"></script>
      <script src="js/script.js"></script>
      <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

   </body>
</html>